<!DOCTYPE html>
<html lang="en">

<div id="manhattan_plot_container"></div>

<div id="variants_table_container">
    <table id="stream_table" class="table table-striped table-bordered">
    <thead>
        <tr>
        <th>Variant</th>
        <th>Nearest Gene(s)</th>
        <th>MAF</th>
        <th>P-value</th>
        <th>Effect Size (se)</th>
        </tr>
    </thead>
    <tbody>
    {% for v in data["unbinned_variants"] %}
    <TR>
        <TD>{{ '{}:{} {}/{}'.format(v["chrom"], v["pos"], v["ref"], v["alt"]) }}</TD>
        <TD>No genes</TD>
        <TD>{{ '{:.2e}'.format(v["maf"]) }}</TD>
        <TD>{{ '{:.2e}'.format(v["pval"]) }}</TD>
        <TD>{{ '{:.2e}'.format(v["effect_size"]) }}</TD>
    </TR>
    {% endfor %}
    </tbody>
    </table>
</div>


<script src="https://cdn.jsdelivr.net/npm/d3@^5.16.0" type="text/javascript"></script>
<script src="https://unpkg.com/d3-tip@0.9.1"></script>
<script src="https://unpkg.com/underscore@1.8.3/underscore-min.js"></script>
<script src="https://unpkg.com/jquery@1.12.4/dist/jquery.min.js"
    integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script>
    // Global variables (hardcoded for now)
    window.model = window.model || {};
    window.model.tooltip_underscoretemplate = `<% if(_.has(d, 'chrom')) { %><b><%= d.chrom %>:<%= d.pos.toLocaleString() %> <%= d.ref %> / <%= d.alt %></b><br><% } %>\n<% if(_.has(d, 'rsids')) { %><% _.each(_.filter((d.rsids||"").split(",")), function(rsid) { %>rsid: <b><%= rsid %></b><br><% }) %><% } %>\n<% if(_.has(d, 'nearest_genes')) { %>nearest gene<%= _.contains(d.nearest_genes, ",")? "s":"" %>: <b><%= d.nearest_genes %></b><br><% } %>\n<% if(_.has(d, 'consequence')) { %>consequence: <b><%= d['consequence'] %></b><br><% } %>\n<% if(_.has(d, 'pval')) { %>P-value: <b><%= d['pval'] %></b><br><% } %>\n<% if(_.has(d, 'beta')) { %>Beta: <b><%= d.beta %></b><% if(_.has(d, "sebeta")){ %> (se:<b><%= d.sebeta %></b>)<% } %><br><% } %>\n<% if(_.has(d, 'or')) { %>Odds Ratio: <b><%= d['or'] %></b><br><% } %>\n<% if(_.has(d, 'maf')) { %>MAF: <b><%= d['maf'] %></b><br><% } %>\n<% if(_.has(d, 'af')) { %>AF: <b><%= d['af'] %></b><br><% } %>\n<% if(_.has(d, 'case_af')) { %>AF among cases: <b><%= d['case_af'] %></b><br><% } %>\n<% if(_.has(d, 'control_af')) { %>AF among controls: <b><%= d['control_af'] %></b><br><% } %>\n<% if(_.has(d, 'ac')) { %>AC: <b><%= d['ac'] %></b><br><% } %>\n<% if(_.has(d, 'r2')) { %>R2: <b><%= d['r2'] %></b><br><% } %>\n<% if(_.has(d, 'tstat')) { %>Tstat: <b><%= d['tstat'] %></b><br><% } %>\n<% if(_.has(d, 'num_cases')) { %>#cases: <b><%= d['num_cases'] %></b><br><% } %>\n<% if(_.has(d, 'num_controls')) { %>#controls: <b><%= d['num_controls'] %></b><br><% } %>\n<% if(_.has(d, 'num_samples')) { %>#samples: <b><%= d['num_samples'] %></b><br><% } %>\n`

    // Fill in the data using jinja and create the GWAS plot
    var data = {{ data | tojson }};
    create_manhattan_plot(data.variant_bins, data.unbinned_variants);

    // Convenience function to format strings
    function fmt(format) {
        var args = Array.prototype.slice.call(arguments, 1);
        return format.replace(/{(\d+)}/g, function (match, number) {
            return (typeof args[number] != 'undefined') ? args[number] : match;
        });
    }

    // Create Manhattan plot
    function create_manhattan_plot(variant_bins, unbinned_variants) {

        // Order from weakest to strongest pvalue, so that the strongest variant will be on top (z-order) and easily hoverable
        // In the DOM, later siblings are displayed over top of (and occluding) earlier siblings.
        unbinned_variants = _.sortBy(unbinned_variants, function (d) { return -d.pval });

        var get_chrom_offsets = _.memoize(function () {
            var chrom_padding = 2e7;
            var chrom_extents = {};

            var update_chrom_extents = function (variant) {
                if (!(variant.chrom in chrom_extents)) {
                    chrom_extents[variant.chrom] = [variant.pos, variant.pos];
                } else if (variant.pos > chrom_extents[variant.chrom][1]) {
                    chrom_extents[variant.chrom][1] = variant.pos;
                } else if (variant.pos < chrom_extents[variant.chrom][0]) {
                    chrom_extents[variant.chrom][0] = variant.pos;
                }
            }
            variant_bins.forEach(update_chrom_extents);
            unbinned_variants.forEach(update_chrom_extents);

            var chroms = _.sortBy(Object.keys(chrom_extents), parseInt);

            var chrom_genomic_start_positions = {};
            chrom_genomic_start_positions[chroms[0]] = 0;
            for (var i = 1; i < chroms.length; i++) {
                chrom_genomic_start_positions[chroms[i]] = chrom_genomic_start_positions[chroms[i - 1]] + chrom_extents[chroms[i - 1]][1] - chrom_extents[chroms[i - 1]][0] + chrom_padding;
            }

            // chrom_offsets are defined to be the numbers that make `get_genomic_position()` work.
            // ie, they leave a gap of `chrom_padding` between the last variant on one chromosome and the first on the next.
            var chrom_offsets = {};
            Object.keys(chrom_genomic_start_positions).forEach(function (chrom) {
                chrom_offsets[chrom] = chrom_genomic_start_positions[chrom] - chrom_extents[chrom][0];
            });

            return {
                chrom_extents: chrom_extents,
                chroms: chroms,
                chrom_genomic_start_positions: chrom_genomic_start_positions,
                chrom_offsets: chrom_offsets,
            };
        });

        function get_genomic_position(variant) {
            var chrom_offsets = get_chrom_offsets().chrom_offsets;
            return chrom_offsets[variant.chrom] + variant.pos;
        }

        function get_y_axis_config(max_data_qval, plot_height, includes_pval0) {

            var possible_ticks = [];
            if (max_data_qval <= 14) { possible_ticks = _.range(0, 14.1, 2); }
            else if (max_data_qval <= 28) { possible_ticks = _.range(0, 28.1, 4); }
            else if (max_data_qval <= 40) { possible_ticks = _.range(0, 40.1, 8); }
            else {
                possible_ticks = _.range(0, 20.1, 4);
                if (max_data_qval <= 70) { possible_ticks = possible_ticks.concat([30, 40, 50, 60, 70]); }
                else if (max_data_qval <= 120) { possible_ticks = possible_ticks.concat([40, 60, 80, 100, 120]); }
                else if (max_data_qval <= 220) { possible_ticks = possible_ticks.concat([60, 100, 140, 180, 220]); }
                else {
                    var power_of_ten = Math.pow(10, Math.floor(Math.log10(max_data_qval)));
                    var first_digit = max_data_qval / power_of_ten;
                    var multipliers;
                    if (first_digit <= 2) { multipliers = [0.5, 1, 1.5, 2]; }
                    else if (first_digit <= 4) { multipliers = [1, 2, 3, 4]; }
                    else { multipliers = [2, 4, 6, 8, 10]; }
                    possible_ticks = possible_ticks.concat(multipliers.map(function (m) { return m * power_of_ten; }));
                }
            }
            // Include all ticks < qval.  Then also include the next tick.
            // That should mean we'll always have the largest tick >= the largest variant.
            var ticks = possible_ticks.filter(function (qval) { return qval < max_data_qval; });
            if (ticks.length < possible_ticks.length) { ticks.push(possible_ticks[ticks.length]); }

            // Use the largest tick for the top of our y-axis so that we'll have a tick nicely rendered right at the top.
            var max_plot_qval = ticks[ticks.length - 1];
            // If we have any qval=inf (pval=0) variants, leave space for them.
            if (includes_pval0) { max_plot_qval *= 1.1 }
            var scale = d3.scaleLinear().clamp(true);
            if (max_plot_qval <= 40) {
                scale = scale
                    .domain([max_plot_qval, 0])
                    .range([0, plot_height]);
            } else {
                scale = scale
                    .domain([max_plot_qval, 20, 0])
                    .range([0, plot_height / 2, plot_height]);
            }

            if (includes_pval0) { ticks.push(Infinity); }

            return {
                'scale': scale,
                'draw_break_at_20': !(max_plot_qval <= 40),
                'ticks': ticks,
            };
        }

        $(function () {
            // Setup plot dimensions
            var svg_width = $('#manhattan_plot_container').width();
            var svg_height = 550;

            var plot_margin = {
                'left': 70,
                'right': 30,
                'top': 20,
                'bottom': 50,
            };

            var plot_width = svg_width - plot_margin.left - plot_margin.right;
            var plot_height = svg_height - plot_margin.top - plot_margin.bottom;

            var gwas_svg = d3.select('#manhattan_plot_container').append("svg")
                .attr('id', 'gwas_svg')
                .attr("width", svg_width)
                .attr("height", svg_height)
                .style("display", "block")
                .style("margin", "auto");

            var gwas_plot = gwas_svg.append("g")
                .attr('id', 'gwas_plot')
                .attr("transform", fmt("translate({0},{1})", plot_margin.left, plot_margin.top));

            // Significance Threshold line
            var significance_threshold = 5e-8; //RB NOTE: make this not hardcoded?

            var genomic_position_extent = (function () {
                var extent1 = d3.extent(variant_bins, get_genomic_position);
                var extent2 = d3.extent(unbinned_variants, get_genomic_position);
                return d3.extent(extent1.concat(extent2));
            })();

            var x_scale = d3.scaleLinear()
                .domain(genomic_position_extent)
                .range([0, plot_width]);

            // Bool indicating whether any variants have pval=0
            var includes_pval0 = _.any(unbinned_variants, function (variant) { return variant.pval === 0; });

            // ???
            var highest_plot_qval = Math.max(
                -Math.log10(significance_threshold) + 0.5,
                (function () {
                    var best_unbinned_qval = -Math.log10(d3.min(unbinned_variants, function (d) {
                        return (d.pval === 0) ? 1 : d.pval;
                    }));
                    if (best_unbinned_qval !== undefined) return best_unbinned_qval;
                    return d3.max(variant_bins, function (bin) {
                        return d3.max(bin, _.property('qval'));
                    });
                })());

            var y_axis_config = get_y_axis_config(highest_plot_qval, plot_height, includes_pval0);
            var y_scale = y_axis_config.scale;

            // ??? Something to do with the y-axis
            var y_axis = d3.axisLeft(y_scale)
                .tickFormat(d3.format("d"))
                .tickValues(y_axis_config.ticks)

            gwas_plot.append("g")
                .attr("class", "y axis")
                .attr('transform', 'translate(-8,0)')
                .call(y_axis);

            // ???
            if (includes_pval0) {
                var y_axis_break_inf_offset = y_scale(Infinity) + (y_scale(0) - y_scale(Infinity)) * 0.03
                gwas_plot.append('line')
                    .attr('x1', -8 - 7).attr('x2', -8 + 7)
                    .attr('y1', y_axis_break_inf_offset + 6).attr('y2', y_axis_break_inf_offset - 6)
                    .attr('stroke', '#666').attr('stroke-width', '3px');
            }

            // Discontinuous y-axis line marker at -log10 20
            if (y_axis_config.draw_break_at_20) {
                var y_axis_break_20_offset = y_scale(20);
                gwas_plot.append('line')
                    .attr('x1', -8 - 7).attr('x2', -8 + 7)
                    .attr('y1', y_axis_break_20_offset + 6).attr('y2', y_axis_break_20_offset - 6)
                    .attr('stroke', '#666').attr('stroke-width', '3px');
            }

            // Y-axis label
            gwas_svg.append('text')
                .style('text-anchor', 'middle')
                .attr('transform', fmt('translate({0},{1})rotate(-90)',
                    plot_margin.left * .4,
                    plot_height / 2 + plot_margin.top))
                .text('-log\u2081\u2080(p-value)'); // Unicode subscript "10"

            // Alternating background colors for chromosomes
            var color_by_chrom = d3.scaleOrdinal()
                .domain(get_chrom_offsets().chroms)
                .range(['rgb(120,120,186)', 'rgb(0,66,66)']);

            // Get chromosome midpoints for labels
            var chroms_and_midpoints = (function () {
                var v = get_chrom_offsets();
                return v.chroms.map(function (chrom) {
                    return {
                        chrom: chrom,
                        midpoint: v.chrom_genomic_start_positions[chrom] + (v.chrom_extents[chrom][1] - v.chrom_extents[chrom][0]) / 2,
                    };
                });
            })();

            // Chromosome labels x-axis
            gwas_svg.selectAll('text.chrom_label')
                .data(chroms_and_midpoints)
                .enter()
                .append('text')
                .style('text-anchor', 'middle')
                .attr('transform', function (d) {
                    return fmt('translate({0},{1})',
                        plot_margin.left + x_scale(d.midpoint),
                        plot_height + plot_margin.top + 20);
                })
                .text(function (d) {
                    return d.chrom;
                })
                .style('fill', function (d) {
                    return color_by_chrom(d.chrom);
                });

            // Significance Threshold line
            gwas_plot.append('line')
                .attr('x1', 0)
                .attr('x2', plot_width)
                .attr('y1', y_scale(-Math.log10(significance_threshold)))
                .attr('y2', y_scale(-Math.log10(significance_threshold)))
                .attr('stroke-width', '5px')
                .attr('stroke', 'lightgray')
                .attr('stroke-dasharray', '10,10')

            // Points & labels
            var tooltip_template = _.template(
                window.model.tooltip_underscoretemplate +
                "<% if(_.has(d, 'num_significant_in_peak') && d.num_significant_in_peak>1) { %>#significant variants in peak: <%= d.num_significant_in_peak %><br><% } %>");

            var point_tooltip = d3.tip()
                .attr('class', 'd3-tip')
                .html(function (d) {
                    return tooltip_template({ d: d });
                })
                .offset([-6, 0]);

            gwas_svg.call(point_tooltip);

            function get_link_to_LZ(variant) {
                return fmt(window.model.urlprefix + '/region/{0}/{1}:{2}-{3}',
                    window.pheno,
                    variant.chrom,
                    Math.max(0, variant.pos - 200 * 1000),
                    variant.pos + 200 * 1000);
            }

            // TODO: if the label touches any circles or labels, skip it?
            var variants_to_label = _.sortBy(_.where(unbinned_variants, { peak: true }), _.property('pval'))
                .filter(function (d) { return d.pval < 5e-8; })
                .slice(0, 7);
            var genenames = gwas_plot.append('g')
                .attr('class', 'genenames')
                .selectAll('text.genenames')
                .data(variants_to_label)
                .enter()
                .append('text')
                .attr('class', 'genename_text')
                .style('font-style', 'italic')
                .attr('text-anchor', 'middle')
                .attr('transform', function (d) {
                    return fmt('translate({0},{1})',
                        x_scale(get_genomic_position(d)),
                        y_scale(-Math.log10(d.pval)) - 5);
                })
                .text(function (d) {
                    if (d.nearest_genes.split(',').length <= 2) {
                        return d.nearest_genes;
                    } else {
                        return d.nearest_genes.split(',').slice(0, 2).join(',') + ',...';
                    }
                });

            function add_variant_points() {
                gwas_plot.append('g')
                    .attr('class', 'variant_points')
                    .selectAll('a.variant_point')
                    .data(unbinned_variants)
                    .enter()
                    .append('a')
                    .attr('class', 'variant_point')
                    .attr('xlink:href', get_link_to_LZ)
                    .append('circle')
                    .attr('id', function (d) {
                        return fmt('variant-point-{0}-{1}-{2}-{3}', d.chrom, d.pos, d.ref, d.alt);
                    })
                    .attr('cx', function (d) {
                        return x_scale(get_genomic_position(d));
                    })
                    .attr('cy', function (d) {
                        return y_scale(-Math.log10(d.pval));
                    })
                    .attr('r', 2.3)
                    .style('fill', function (d) {
                        return color_by_chrom(d.chrom);
                    })
                    .on('mouseover', function (d) {
                        //Note: once a tooltip has been explicitly placed once, it must be explicitly placed forever after.
                        point_tooltip.show(d, this);
                    })
                    .on('mouseout', point_tooltip.hide);
            }
            add_variant_points();

            function add_variant_bins() {
                var bins = gwas_plot.append('g')
                    .attr('class', 'bins')
                    .selectAll('g.bin')
                    .data(variant_bins)
                    .enter()
                    .append('g')
                    .attr('class', 'bin')
                    .attr('data-index', function (d, i) { return i; }) // make parent index available from DOM
                    .each(function (d) { //todo: do this in a forEach
                        d.x = x_scale(get_genomic_position(d));
                        d.color = color_by_chrom(d.chrom);
                    });

                bins.selectAll('circle.binned_variant_point')
                    .data(_.property('qvals'))
                    .enter()
                    .append('circle')
                    .attr('class', 'binned_variant_point')
                    .attr('cx', function (d, i) {
                        var parent_i = +this.parentNode.getAttribute('data-index');
                        return variant_bins[parent_i].x;
                    })
                    .attr('cy', function (qval) {
                        return y_scale(qval);
                    })
                    .attr('r', 2.3)
                    .style('fill', function (d, i) {
                        var parent_i = +this.parentNode.getAttribute('data-index');
                        return variant_bins[parent_i].color;
                    });

                bins.selectAll('circle.binned_variant_line')
                    .data(_.property('qval_extents'))
                    .enter()
                    .append('line')
                    .attr('class', 'binned_variant_line')
                    .attr('x1', function (d, i) {
                        var parent_i = +this.parentNode.getAttribute('data-index');
                        return variant_bins[parent_i].x;
                    })
                    .attr('x2', function (d, i) {
                        const parent_i = +this.parentNode.getAttribute('data-index');
                        return variant_bins[parent_i].x;
                    })
                    .attr('y1', function (d) { return y_scale(d[0]); })
                    .attr('y2', function (d) { return y_scale(d[1]); })
                    .style('stroke', function (d, i) {
                        var parent_i = +this.parentNode.getAttribute('data-index');
                        return variant_bins[parent_i].color;
                    })
                    .style('stroke-width', 4.6)
                    .style('stroke-linecap', 'round');
            }
            add_variant_bins();

        });
    }

</script>

</html>
